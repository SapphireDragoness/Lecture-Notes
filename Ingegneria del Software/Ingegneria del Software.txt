#separator:tab
#html:true
Tipi di requisiti non funzionali	Prodotto, organizzativi (sviluppo e gestionali), esterni (giuridici e compatibilità)
Tipi di requisiti di prodotto	Usabilità, mantenibilità, portabilità, efficienza, affidabilità (reliability, availability, safety, security), recoverability
Fasi del processo di specifica e cosa accade in ognuno di essi	<ol><li>Studio di fattibilità: valutazione della possibilità di sviluppare il sistema e dei suoi vantaggi per il committente</li><li>Deduzione dei requisiti: raccolta informazioni da cui dedurre quali sono i requisiti</li><li>Analisi dei requisiti: organizzazione, negoziazione e modellazione dei requisiti</li><li>Validazione dei requisiti: verifica del rispetto di alcune proprietà da parte del documento dei requisiti</li></ol>
Gradi di dettaglio dei requisiti	<ul><li>Requisito utente: descritto ad alto livello, risultato della deduzione dei requisiti, espresso in linguaggio naturale, letto da persone senza approfondita conoscenza tecnica</li></ul><ul><li>Requisito di sistema: descritto dettagliatamente, risultato dell'analisi dei requisiti, letto da persone del campo, espresso in linguaggio formale</li></ul>
Quali documenti sono prodotti da ogni fase del processo di specifica	<ol><li>Studio di fattibilità: rapporto di fattibilità</li><li>Deduzione dei requisiti: requisiti utente</li><li>Analisi dei requisiti: requisiti di sistema</li><li>Validazione dei requisiti: documento dei requisiti</li></ol>
Modi in cui è possibile dedurre i requisiti	<ul><li>Studio del dominio applicativo: studio dell'insieme di entità reali su cui il sistema software ha effetto</li><li>Dialogo con stakeholder: tramire interviste e etnografia</li><li>Studio di sistemi già realizzati sullo stesso dominio applicativo</li><li>Studio di sistemi con cui dovrà interagire quello da sviluppare</li></ul>
Problemi con stakeholder e linguaggio naturale	<ul><li>Gli stakeholder non sanno indicare chiaramente cosa vogliono dal sistema</li><li>Omettono informazioni che possono sembrare ovvie</li><li>Problemi di tempo e distanza</li><li>Conflitti nella dichiarazione dei requisiti</li><li>Mancanza di chiarezza, confusione, mescolanza di requisiti</li></ul>
Attività svolte durante l'analisi dei requisiti	<ul><li>Classificazione e organizzazione dei requisiti</li><li>Assegnazione di priorità ai requisiti</li><li>Negoziazione dei requisiti</li><li>Modellazione analitica dei requisiti</li></ul>
Modi per rappresentare i requisiti di sistema	<ul><li>Linguaggio naturale strutturato (template)</li><li>Modelli grafici (UML)</li><li>Notazione basata su trasformazione funzionale (data-flow)</li><li>Notazione matematica</li></ul>
Proprietà da verificare durante la validazione dei requisiti	<ul><li>Completezza: tutti i requisiti richiesti dal committente devono essere documentati</li><li>Coerenza: la specifica dei requisiti non deve contenere definizioni tra loro contraddittorie</li><li>Precisione: l'interpretazione di una definizione di requisito deve essere unica</li><li>Realismo: i requisiti possono essere implementati date le risorse disponibili<br></li><li>Tracciabilità</li></ul>
Tipi di tracciabilità dei requisiti	<ul><li>Sorgente: un requisito è tracciabile quando si riesce a reperire la fonte di informazione relativa al requisito</li><li>Requisiti: un requisito è tracciabile quando si riesce a individuare i requisiti dipendenti</li><li>Progetto: individuare i componenti del sistema che realizzano il requisito</li><li>Test: individuare i test-case usati per collaudare un requisito</li></ul>
Tipi di tecniche di validazione	<ul><li>Revisione: un gruppo di revisori controlla i requisiti</li><li>Costruzione di prototipi: uno o più prototipi sono generati e mostrati al committente e agli utenti per verificare la comprensione dei requisiti</li></ul>
Attività svolte durante la progettazione	<ul><li>Progettazione architetturale: si definiscono sistemi e moduli (strutturazione), distribuzione dei componenti (deployment), quali componenti invocano le operazioni e quali le eseguono (metodo di controllo) e si definiscono le interazioni tra componenti allo scopo di svolgere una certa funzione (modellazione del comportamento)</li><li>Progettazione delle strutture dati</li><li>Progettazione degli algoritmi</li><li>Progettazione della GUI</li></ul>
Tipi di modello (diagrammi) usati nella progettazione	<ul><li>Progettazione architetturale: component diagram, deployment diagram, class diagram, package diagram e diagrammi di sequenza (UML)</li><li>Progettazione delle strutture dati: E-R, modello relazionale; diagramma delle classi (UML)</li><li>Progettazione degli algoritmi: diagrammi di flusso; diagrammi d'attività (UML)</li><li>Progettazione GUI: sketch</li></ul>
Strati nei quali viene suddiviso un sistema ed il loro scopo	<ul><li>Presentazione: raccolta degli input dell'utente, visualizzazione output</li><li>Elaborazione: elaborazione dei dati in input e produzione dati in output</li><li>Gestione dei dati: aggiunta, modifica, rimozione e ricerca dati</li></ul>
Tipi di componenti	<ul><li>Sottosistema: parte del sistema dedicata a svolgere una certa attività</li><li>Modulo: parte di un sottosistema dedicata a svolgere particolari funzioni legate all'attività del sottosistema</li></ul>
Tipi di soluzione nel 2-tiers deployment	"<ul><li>Thin client: la macchina ""client"" si occupa della presentazione, la macchina ""server"" si occupa di elaborazione e gestione dati</li><li>Fat client: la macchina ""client"" si occupa della presentazione e dell'elaborazione, la macchina ""server"" si occupa della gestione dati</li></ul>"
Differenza tra interfaccia e corpo	<ul><li>Interfaccia: insieme di operazioni che il componente mette a disposizione di altri componenti</li><li>Corpo: parte interna del componente, è nascosta agli altri componenti</li></ul>
Stili di controllo	<ul><li>Centralizzato: un componente ha il compito specifico di controllo, attiva o disattiva gli altri componenti</li><li>Basato su eventi: ogni componente si attiva autonomamente come reazione ad eventi esterni determinati da altri componenti o dall'ambiente</li><li>Call-return: un componente principale attiva altri componenti che a loro volta ne attiivano altri</li><li>Client-server: un componente client attiva uno o più componenti server</li></ul>
Controlli effettuati durante il collaudo	<ul><li>Verifica: si controlla che il prodotto implementato realizzi ogni servizio senza malfunzionamenti, al fine di scoprire bug sìdi sistema</li><li>Validazione: si controlla che il prodotto implementato soddisfi i requisiti del committente, al fine di scoprire anomalie o omissioni</li></ul>
Tipi di tecniche per individuare un difetto	<ul><li>Tecnica statica (ispezione): basata sulla lettura del codice e della documentazione, il sistema non viene messo in esecuzione</li><li>Tecnica dinamica (testing): il sistema viene messo in esecuzione, si osserva come il sistema si comporta qundo elabora test-case&nbsp;</li></ul>
Fasi del processo di ispezione	<ul><li>Pianificazione: il moderatore seleziona gli ispettori e controlla che il materiale (codice, documentazione) sia completo</li><li>Introduzione: il moderatore oragnizza una riunione preliminare con autori e ispettori</li><li>Preparazione individuale: gli ispettori studiano il materiale e cercano difetti nel codice in base alla checklist e all'esperienza personale</li><li>Riunione di ispezione: gli ispettori indicano i difetti individuati</li><li>Rielaborazione: il programma è modificato dall'autore per correggere i difetti</li><li>Prosecuzione: il moderatore decide se è necessario un ulteriore processo di ispezione</li></ul>
Tipi di analisi svolte durante l'analisi statica	<ul><li>Analisi del flusso di controllo: cicli con uscite multiple, salti incondizionati, codice non raggiungibile</li><li>Analisi dell'uso dei dati: variabili non inizializzate, variabili dichiarate ma non usate, violazione limiti di un array, condizioni semrpe false/vere</li><li>Analisi delle interfacce: consistenza delle dichiarazioni di metodi e funzioni, risultati mai usati</li><li>Analisi della gestione della memoria: puntatori non assegnati, errori nell'aritmetica dei puntatori</li></ul>
Fasi del processo di testing	<ul><li>Preparazione dei test-case</li><li>Esecuzione dei un test case</li><li>Confronto dei risultati di output con i dati attesi</li><li>Debugging: si controlla l'esecuzione del programma, i valori delle variabili e si scopre la posizione dell'errore</li><li>Correzione dell'errore: si modifica il codice per eliminare il difetto</li><li>Testing di regressione: si ripete l'ultimo test case e tutti i test case precedenti</li></ul>
Approcci per scegliere i test case	<ul><li>Black box: la scelta dei test case è basata sulla conoscenza di quali sono i dati in input e i dati in output</li><li>White box: la scelta dei test case è basata sulla struttura del codice</li></ul>
Tipi di testing nell'integrazione incrementale	<ul><li>Testing dei componenti: testing di ogni componente considerato in modo isolato</li><li>Testing d'integrazione: si testa il sistema costituito dai componenti testati ed integrati fin'ora<br></li><li>Release testing: testing del sistema costituito da tutti i componenti</li></ul>
Tipi di manutenzione	<ul><li>Correttiva: correzione di difetti non emersi in fase di collaudo (difetti di implementazione, progettazione o specifica)</li><li>Adattiva: adattamento del sistema a cambiamenti di piattaforma</li><li>Migliorativa: aggiunta, cambiamento o miglioramento di requisiti funzionali e non, secondo le richieste del committente o tendenze di mercato</li></ul>
Fattori che influenzano il costo di manutenzione	<ul><li>Dipendenza dei componenti: la modifica di un componente potrebbe avere ripercussioni sugli altri componenti</li><li>Linguaggio di programmazione: i programmi scritti con linguaggi ad alto livello sono più facili da capire e quindi da mantanere</li><li>Struttura del codice: il codice ben strutturato e documentato rende più facile la manutenzione</li><li>Collaudo: una fase di collaudo approfondita riduce il numero di difetti scoperti successivamente alla consegna</li><li>Qualità della documentazione: una documentazione chiara e completa facilita la comprenzone del sistema da mantenere</li><li>Stabilità dello staff: i costi si riducono se lo steff che ha sviluppato il prodotto è lo stesso che lo mantiene</li><li>Età del sistema: il costo di manutenzione tende a crescere con l'età del sistema</li><li>Stabilità del dominio dell'applicazione: se il dominion subisce variazioni, il sistema deve essere aggiornato</li><li>Stabilità della piattaforma: il cambiamento della piattaforma può richiedere la manutenzione del software</li></ul>
Fasi del processo di manutenzione	<ul><li>Identificazione dell'intervento: arrivo di una richiesta di modifica</li><li>Analisi dell'impatto: inidviduazione dei requisiti, componenti operazioni e test case influenzati dalla modifica; individuazione soluzioni e valutazione risorse</li><li>Painificazione della release: selezionare la soluzione migliore e accettare/rifiutare la modifica</li><li>Realizzazione della modifica: se necessario, aggiornare specifica, progettazione o implementazione, nuovo collaudo</li><li>Rilascio della nuova versione del sistema</li></ul>
Differenza tra versione e release	<ul><li>Versione: istanza del sistema che differisce per qualche aspetto dalle altre istanze</li><li>Release: una particolare versione che viene distribuita a committenti/clienti</li></ul>
Strategie per i sistemi ereditati	<ul><li>Manutenzione ordinaria del sistema</li><li>Software re-engineering: ristrutturazone dei sistemi ereditati per renderli più mantenibili</li><li>Reimplementazione del sistema mantenendo gli stessi requisiti funzionali</li><li>Dismissione: cambiare la propria organizzazione in modo che l'uso del sistema non sia più necessario</li></ul>
Differenza tra forward-engineering e re-engineering	<ul><li>Forward-engineering: è il processo software, si crea un nuovo prodotto partendo dalla specifica dei requisiti</li><li>Re-engineering: il nuovo sistema è dato da qualche trasformazione del vecchio, allo scopo di rinnocarlo e aumentarne la mantenibilità, non vengono modificati i requisiti funzionali o il comportamento del sistema</li></ul>
Attività di gestione	<ul><li>Scrittura proposte: per ottenere un contratto o vincere una gara d'appalto</li><li>Pianificazione: task, milestone, risorse</li><li>Stima dei costi:</li><li>Gestione dei rischi: previsione di problemi e soluzioni</li><li>Monitoraggio del processo: si valutano i progressi del processo, e si confrontano con la pianificazione</li><li>Scrittura e presentazione di rapporti: si informa il committente sull'avanzamento del progetto</li><li>Revisione del progetto: aggiornamento della pianificazione, della stima dei costi e della gestione dei rischi</li></ul>
Attività di pianificazione	<ul><li>Scomposizione del processo in task: identificazone delle dipendenze tra task e definizione di milestone e deliverable</li><li>Assegnazione delle risorse ad ogni task</li><li>Tempistica: stima dei tempi</li></ul>
Fasi del processo di gestione dei rischi	<ul><li>Identificazione dei rischi: identificare i rischi potenziali e la loro natura</li><li>Analisi dei rischi: determinare la probabilità di ogni rischio e la gravità delle sue conseguenze</li><li>Pianificazione dei rischi: piani per affrontare i rischi</li><li>Monitoring dei rischi: si controlla se la probabilità o la gravità degli effetti di&nbsp; ogni rischio sono cambiate</li></ul>
Tipi di rischio in base alla fonte	<ul><li>Tecnologici: derivano dall'hw o sw utilizzati</li><li>Riguardanti il personale: derivano dal personale del team</li><li>Organizzativi: derivano dall'organizzazione aziendale</li><li>Strumentali: derivano dagli strumenti CASE</li><li>Requisiti: derivano dal cambiamento dei requisiti</li><li>Stima: derivano dalle valutazioni relaztive a tempi, costi, risorse del sistema</li></ul>
Tipi di rischio in base all'effetto	<ul><li>Progetto: colpiscono la pianificazione</li><li>Prodotto: colpiscono la qualità del prodotto</li><li>Business: colpiscono il committente/cliente o lo sviluppatore su piano economico</li></ul>
Attributi del modello a cascata	<ul><li>Visibilità alta: ogni fase della documentazione ne descrive i risultati e le fasi sono ben distinte</li><li>Affidabilità bassa: si collauda il sistema in blocco e il committente può controllare il soddisfacimento dei requisiti solo alla consegna</li><li>Robustezza bassa: i requisiti non devono cambiare</li><li>Rapidità bassa: il committente può disporre del sistema solo alla consegna<br></li></ul>
Tipi di prototipo	"<ul><li>Prototipo ""usa e getta"": utile se combinato con il modello a cascata, ha lo scopo di comprendere un insieme di requisiti poco chiari<br></li><li>Prototipo evolutivo: usato nel modello di sviluppo evolutivo, il prototipo realizza i requisiti del ciclo corrente mantenendo quelli dei cicli precedenti</li></ul>"
Attributi dello sviluppo basato sul riuso	<ul><li>Visibilità alta</li><li>Affidabilità media: i componenti pre-esistenti sono già stati collaudati</li><li>Robustezza media: riduzione dei costi e dei rischi</li><li>Rapidità media: consegna più veloce dato che alcune componenti sono già state sviluppate<br></li></ul>
Attributi dello sviluppo evolutivo	<ul><li>Visibilità bassa: la documentazione non viene sempre aggiornata</li><li>Affidabilità: il collaudo riguarda un sottoinsieme di requisiti e il committente può valutare ogni versione</li><li>Robustezza media: i processo supporta il cambiamento dei requisiti, ma il codice rischia di diventare poco strutturato</li><li>Rapidità media: vi è la disponibilità anticipata di un prototipo funzionante, ma la consegna richiede comunque l'attesa del tempo necessario per il processo dei singoli requisiti</li></ul>
Differenze tra sviluppo evolutivo e incrementale	<ul><li>Sviluppo evolutivo: non è prevedibile il numero di versioni intermedie necessarie per arrivare alla versione completa del sistema</li><li>Sviluppo incrementale: mantiene i vantaggi dello sviluppo evolutivo, ed ha maggiore visibilità in quanto si definiscono a priori il numero delle versioni del prototipo per arrivare al sistema finale</li></ul>
Attributi dello sviluppo incrementale	<ul><li>Visibilità alta: il processo è meno soggetto all'inertezza, dato che all'inizio del processo si definiscono l'architettura del sistema, il numero di incrementi e il loro ordine</li><li>Affidabilità: come sviluppo evolutivo</li><li>Robustezza media: supporta il cambiamento dei requisiti</li><li>Rapidità: come sviluppo evolutivo</li></ul>
Attributi dell'UP	<ul><li>Visibilità media: le 4 fasi (avvio, elaborazione, costruzione e transizione) sono ben distinte e producono documentazione, ma non si sa a priori quante volte saranno ripetute</li><li>Affidabilità media: prevede piano di collaudo, testing e beta testing</li><li>Robustezza media: prevede prototipo evolutivo, feedback, gestione dei rischi</li><li>Rapidità media: ogni fase produce un prototipo evolutivo e ogni fase prevede un insieme consistente di attività da svolgere</li></ul>
Modi con i quali XP ottiene rapidità e affidabilità	Rapidità:<br><ul><li>specifica ad alto livello e progettazione semplice</li><li>uso di strumenti CASE durante il collaudo</li><li>release frequenti</li></ul><div><br></div><div>Affidabilità:</div><div><ul><li>programmazione a coppie</li><li>possesso collettivo</li><li>test case definiti durante la pianificazione</li><li>tesing ad ogni incremento</li></ul></div>
Attributi di XP	<ul><li>Visibilità bassa: non c'è documentazione nella sua forma classica, non si conosce il numero di versioni per arrivare alla fine</li><li>Affidabilità alta</li><li>Robustezza alta: supporta il cambiamento dei requisiti e il codice rimane ben strutturato e ordinato</li><li>Rapidità alta: specifica e progettazione ad alto livello, release frequenti</li></ul>
Tipi di meeting nel modello Scrum	<ul><li>Sprint planning meeting: riunione all'inizio di ogni sprint; si aggiorna il product backlog, si definisce lo sprint backlog e lo sprint goal</li><li>Scrum meeting: riunione giornaliera; ogni sviluppatore desccrive cosa ha fatto il giorno prima e cosa farà nel giorno corrente, si controlla l'avanzamento del lavoro</li><li>Sprint review meeting: riunione alla fine di ogni sprint; si mostra il prototipo corrente e si giudica se lo sprint goal è stato raggiunto o meno</li></ul>
Attributi del modello Scrum	<ul><li>Visibilità media: controllo giornaliero dell'avanzamento del lavoro, non si conosce a priori il numero di sprint</li><li>Affidabilità alta: coinvolgimento costante del committente, collaudo effettuato per ogni prototipo</li><li>Robustezza alta: gli impedimenti sono risolti giornalmente, il backlog può essere modificato dopo ogni sprint</li><li>Rapidità alta: il prototipo viene rilasciato ogni mese</li></ul>
Processi interni a DevOps	<ul><li>Processo CI (Continuous Integration and testing): gli sviluppatori integrano il codice diverse volte al giorno tramite repository condiviso, ad ogni check-in il codice viene assemblato e testato automaticamente</li><li>Processo CD (Continuous Delivery and deployment): ogni singola modifica che passa i test viene distribuita</li><li>Processo CO (Continuous Operations): le modifiche non devono interrompere l'uso da parte degli utenti finali, monitoring costante da parte degli amministratori di sistema</li><li>Processo CA (Continuous Assessment): continuo monitoraggio dello stato delle prestazioni e assegnamento di priorità e risorse in base ai feedback</li></ul>
Attributi di DevOps	<ul><li>Visibilità media: non si conoscono il numero e frequenza delle release</li><li>Affidabilità alta: integrazione e collaudo automatico ad ogni commit</li><li>Robustezza alta: feedback numerosi e frequenti, monitoring costante</li><li>Rapidità alta: software rilasciato in modo continuo e automatico</li></ul>
