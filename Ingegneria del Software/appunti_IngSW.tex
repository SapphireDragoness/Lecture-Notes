\documentclass[11pt]{article}
\usepackage[margin=.8in]{geometry}
\usepackage[italian]{babel}
\usepackage{graphicx}

\title{Appunti Ingegneria del Software}

\begin{document}
\section{Introduzione}
\subsection{Sistemi software}
Un \textit{sistema software} è un insieme di componenti software che funzionano in modo coordinato allo scopo di informatizzare 
una certa attività. La realizzazione di un sistema software richiede l'impiego di un gruppo di lavoro, nel quale ogni 
persona ricopre un ruolo ben preciso e le attività dei vari gruppi vanno coordinate, e tempo da dedicare alle varie fasi 
di sviluppo.

Esistono due categorie di sistemi software: i \textit{sistemi generici}, definiti in base alle tendenze di mercato, e i 
\textit{sistemi customizzati}, richiesti da uno specifico cliente (il committente).
\subsection{Il processo software}
Con \textit{ingegneria del software} si intende l'applicazione del processo dell'Ingegneria alla produzione di sistemi 
software. Il processo è suddiviso in:
\begin{itemize}
    \item specifica: definizione dei requisiti funzionali e non funzionali 
    \item progettazione: si definiscono architettura, controllo, comportamento dei componenti, strutture dati, algoritmi,
    struttura del codice, interfaccia utente
    \item implementazione: scrittura del codice e integrazione dei moduli 
    \item collaudo: si controlla se il sistema ha difetti di funzionamento e se soddisfa i requisiti 
    \item manutenzione: modifiche del sistema dopo la consegna 
\end{itemize}
\subsection{Gestione del processo}
L'ingegneria del software si occupa anche della gestione del progetto che si svolge in parallelo al processo software.
Le principali attività di gestione sono l'\textit{assegnazione} di risorse (umane, finanziarie...), la \textit{stima del tempo}
necessario per ogni attività, la \textit{stima dei costi} e la \textit{stima dei rischi}.
\section{Specifica}
La \textit{specifica} è l'insieme di attività necessarie per generare il documento dei requisiti che descrive i 
\textit{requisiti funzionali} e i \textit{requisiti non funzionali}: descrive il "cosa" il sistema deve fare, non il "come".
I requisiti servono per una proposta di contratto e modellare fasi successive del processo software.
\subsection{Requisiti funzionali}
I requisiti funzionali sono i servizi che il cliente richiede al sistema. Per ogni servizio si descrive:
\begin{itemize}
    \item cosa accade nell'interazione tra utente e sistema 
    \item cosa accade in seguito ad un certo input o stimolo
    \item cosa accade in particolari sistuazioni, ad esempio in caso di eccezioni
\end{itemize}
Non viene descritto come funziona internamente il sistema, in quanto è oggetto della successiva fase di progettazione.
\subsection{Requisiti non funzionali}
I requisiti non funzionali sono divisi in tre categorie: \textit{requisiti di prodotto}, \textit{requisiti organizzativi}
e \textit{requisiti esterni}.

I requisiti di prodotto sono attributi che definiscono la qualità del sistema. Una \textit{proprietà complessiva} riguarda
il sistema nel suo complesso; una \textit{proprietà emergente} è una proprietà che "emerge" dal funzionamento del sistema, 
dopo che è stato implementato.

I requisiti organizzativi sono caratteristiche riguardanti le fasi del processo software o la gestione del progetto. I 
\textit{requisiti di sviluppo} sono i metodi e le tecniche di sviluppo utilizzati; i \textit{requisiti gestionali} sono
le risorse utilizzate.

I requisiti esterni derivano da fattori esterni al sistema e al processo software. Essi sono i requisiti di compatibilità
con altri sistemi e aspetti giuridici.
\begin{center}
    \includegraphics[scale=0.4]{reqnfunz.jpeg}
\end{center}
\subsubsection*{Usabilità}
L'\textit{usabilità} è il grafo di facilità con cui l'utente riesce a comprendere l'uso del software. Il sistema deve avere 
un'interfaccia utente intuitiva ed curata, in quanto è fattore critico per il successo di un prodotto.
L'uso del sistema deve essere ben documentato, per permettere all'utente di apprendere velocemente l'uso del prodotto.
Il \textit{training} degli utenti può migliorare l'usabilità del prodotto.
\subsubsection*{Mantenibilità}
la \textit{mantenibilità} è il grado di facilità di manutenzione. Le cause della manutenzione sono molteplici, e deve 
essere possibile l'evoluzione del software per soddisfare i requisiti nel tempo.
\subsubsection*{Portabilità}
La \textit{portabilità} è la capacità di migrazione da un ambiente ad un altro.
\subsubsection*{Recoverability}
La \textit{recoverability} è la capacità di ripristinare lo stato e i dati del sistema dopo che si è verificato un fallimento.
\subsubsection*{Efficienza}
L'\textit{efficienza} è il livello di prestazioni del sistema, e può essere misurato in vari modi: tempo di risposta, 
numero medio di richieste... 
\subsubsection*{Affidabilità}
L'\textit{affidabilità} è il grado di fiducia con cui si ritiene che il sistema svolga in modo corretto la propria funzione.
Ci sono varie misure di affidabilità:
\begin{itemize}
    \item \textit{reliability}: capacità di fornire i servizi in modo continuativo per una certa durata di tempo 
    \item \textit{availability}: capacità di fornire i servizi nel momento richiesto
    \item \textit{safety}: capacità di operare senza causare danni materiali
    \item \textit{security}: capacità di proteggersi da intrusioni e attacchi
\end{itemize}
Un sistema è definito \textit{critico} quando il suo non corretto funzionamento può provocare conseguenze "disastrose"
a persone e ambiente (\textit{safety critical system}) o perdite economiche (\textit{business critical system}).
Il costo cresce in modo esponenziale rispetto al grado di affidabilità richiesto.
\subsection{Processo di specifica}
Il \textit{processo di specifica} è il processo per generare il documento dei requisiti, ed è diviso in più fasi.
Lo stesso requisito viene definito con due gradi di dettaglio diversi. Il \textit{requisito utente} è descritto ad alto 
livello, in linguaggio naturale, ed è il risultato della deduzione dei requisiti.
Il \textit{requisito di sistema} è descritto dettagliatamente, fornendo tutti i dettagli necessari per la fase di progettazione,
ed è il risultato dell'analisi dei requisiti.
\subsubsection*{Studio di fattibilità}
Lo \textit{studio di fattibilità} è la valutazione della possibilità di sviluppare il sistema e dei suoi vantaggi per 
il committente. Si decide se la costruzione del sistema è fattibile date le risorse disponibili e se il sistema è 
effettivamente utile al cliente.
Per svolgere lo studio si raccolgono informazioni e si prepara un rapporto di fattibilità, che contiene la valutazione 
della possibilità di costruire un sistema e dei vantaggi che possono derivare dalla sua introduzione.
\subsubsection*{Deduzione dei requisiti}
La \textit{deduzione dei requisiti} è la raccolta di informazioni da cui dedurre quali sono i requisiti.
Le informazioni si possono raccogliere mediante uno studio del dominio applicativo del sistema richiesto, il dialogo con 
stakeholder, studio di sistemi simili già realizzati e studio di sistemi con cui dovrà interagire quello da sviluppare.

Il \textit{dominio applicativo} è l'insieme di entità reali su cui il sistema software ha effetto.

Uno \textit{stakeholder} è, in ambito economico, il soggetto che può influenzare il successo di un'impresa o che ha 
interessi nelle decisioni dell'impresa; in ambito del processo software sono persone che possono influenzare il processo 
o che hanno interesse nelle decisioni assunte in esso.

È possibile dialogare con gli stakeholder tramite \textit{interviste}, nelle quali viene chiesto di raccontare attraverso 
degli esempi reali come l'attività lavorativa funziona realmente, e tramite \textit{etnografia}, l'osservazione dei potenziali 
utenti nello svolgimento delle loro mansioni.

Il dialogo con gli stakeholder presenta vari problemi, in quanto non sono in grado di indicare chiaramente cosa vogliono 
dal sistema, omettendo informazioni ritenute ovvie ed utilizzando terminologia non adatta. Inoltre, lo stesso requisito 
può essere espresso da più stakeholder in maniera differente, ed addirittura essere in conflitto.

Molti problemi scaturiscono dal \textit{linguaggio naturale}, in quanto una descrizione ad alto livello di un requisito 
può generare confusione. La soluzione è quella di utilizzare il linguaggio in modo coerente, evitando gergo tecnico ed 
illustrando i requisiti tramite semplici diagrammi.
\subsubsection*{Analisi dei requisiti}
La \textit{analisi dei requisiti} è l'organizzazione, negoziazione e modellazione dei requisiti.
Comprende:
\begin{itemize}
    \item \textit{classificazione e organizzazione dei requisiti}
    \item \textit{assegnazione di priorità ai requisiti}: si stabilisce il grado di rilevanza di ogni requisito 
    \item \textit{negoziazione dei requisiti}
    \item \textit{modellazione analitica dei requisiti}: produzione di modelli che rappresentano o descrivono nel dettaglio 
    i requisiti 
\end{itemize}
I \textit{requisiti di sistema} sono l'espansione dei requisiti utente, e formano la base per la progettazione. Il linguaggio
naturale non è adatto alla definizione di un requisito di sistema, quindi è necessario usare template, modelli grafici o 
notazione matematica.

Il \textit{modello data-flow}, detto anche pipe \& filter, permette di modelalre il flusso e l'elaborazione dei dati, ma 
non prevede la gestione degli errori. L'elaborazione è di tipo batch: input $\rightarrow$ elaborazione $\rightarrow$ output.

I requisiti non funzionali si possono specificare definendone delle misure quantitative:
\begin{itemize}
    \item \textit{efficienza}: tempo di elaborazione delle richieste, occupazione di memoria
    \item \textit{affidabilità}: probabilità di malfunzionamento, disponibilità
    \item \textit{usabilità}: tempo di addestramento, aiuto contestuale
\end{itemize}

Il \textit{documento dei requisiti} contiene il risultato della deduzione e dell'analisi, ed è la dichiarazione ufficiale 
di ciò che si deve sviluppare. Il documento contiene una breve introduzione che descrive le funzionalità del sistema, un 
glossario contenente le definizione di termini tecnici, i requisiti utente e i requisiti di sistema, correlati con modelli 
UML. Il documento è letto da tutte le figure coinvolte nella realizzazione del progetto.
\subsubsection*{Validazione dei requisiti}
La \textit{validazione dei requisiti} è la verifica del rispetto di alcune proprietà da parte del documento dei requisiti,
serve ad evitare la scoperta di \textit{errori di specifica} durante le fasi successive del processo software. Sono da 
verificare le segueni proprietà:
\begin{itemize}
    \item \textit{completezza}: tutti i requisiti richiesti dal committente devono essere documentati
    \item \textit{coerenza}: la specifica dei requisiti non deve contenere definizioni tra loro contraddittorie
    \item \textit{precisione}: l'interpretazione di una definizione di requisito deve essere unica
    \item \textit{realismo}: i requisiti devono essere implementati date le risorse disponibili
    \item \textit{tracciabilità}
\end{itemize}

Quando si modifica un requisito bisogna valutarne l'impatto sul resto della specifica: è quindi necessario tracciarlo.
Vari tipi di \textit{tracciabilità}:
\begin{itemize}
    \item \textit{tracciabilità della sorgente}: reperire la fonte d'informazione relativa al requisito
    \item \textit{tracciabilità dei requisiti}: individuare i requisiti dipendenti
    \item \textit{tracciabilità del progetto}: individuare i componenti del sistema che realizzano il requisito
    \item \textit{tracciabilità dei test}: individuare i test-case usati per collaudare il requisito
\end{itemize}

Per validare i requisiti si può impegare un gruppo di \textit{revisori} che ricontrolli i requisiti e \textit{costruire 
dei prototipi}.
\section{Progettazione}
\subsection{Attività di progettazione}
Durante la fase di \textit{progettazione architetturale} viene definita la struttura del sistema, come questo verrà 
distribuito e come il sistema si dovrà comportare. Sono inoltre progettate le strutture dati, gli algoritmi e la GUI.
\subsection{Progettazione architetturale}
\subsubsection*{Strutturazione}
Il sistema può essere strutturato in vari sottosistemi (strati), tipicamente tre. Ogni strato interagisce con gli strati 
adiacenti. Gli strati sono:
\begin{itemize}
    \item \textit{presentazione}: l'interfaccia utente, raccoglie i dati dall'utente
    \item \textit{elaborazione}:  elabora i dati in input e produce dati in output
    \item \textit{gestione dei dati}: il database
\end{itemize}

Un \textit{sottosistema} è la parte del sistema dedicata a svolgere una certa attività, mentre un \textit{modulo} è la 
parte del sottosistema dedicata a svolgere particolari funzioni legate all'attività del sottosistema.
\subsubsection*{Deployment}
Con \textit{deployment} si intende la distribuzione dei componenti in vari dispositivi hardware. Nel \textit{deployment 
a 1-tier} i tre stati del sistema sono concentrati su un dispositivo, in quello a \textit{2-tiers} su due e in quello a 
\textit{3-tiers} su tre.

Con deployment a 2-tiers si possono avere due soluzioni: \textit{fat client} e \textit{thin client}.
Nel modello \textit{thin client}, il server si occupa dell'elaborazione e della gestione dei dati, mentre il client si 
occupa della presentazione.
Nel modello \textit{fat client}, il server si occupa della gestione dei dati, mentre il client si occupa della presentazione 
e dell'elaborazione.
\subsubsection*{Metodo di controllo}
Un componente fornisce servizi ad altri componenti. Un'\textit{interfaccia} è un insieme di operazioni che il componente
mette a disposizione di altri componenti ed è condivisa con i componenti che lo invocano. Un \textit{corpo} è la parte 
interna del componente e non è conosciuto agli altri componenti. La separazione tra interfaccia e corpo è detta 
\textit{information hiding}.

Esistono diversi stili di controllo (attivazione) tra componenti:
\begin{itemize}
    \item controllo \textit{centralizzato}: è presente un componente detto \textit{controllore}, che controlla l'attivazione 
    e il coordinamento degli altri componenenti
    \item controllo \textit{basato su eventi}: è basato su eventi esterni (ad esempio un segnale) ed ogni componente si
    occupa di gestire determinati eventi; il gestore degli eventi è detto \textit{broker}, che rileva l'evento e lo notifica 
    tramite broadcast (selettivo o non selettivo)
    \item controllo \textit{call-return}: il controllo passa dall'alto verso il basso
    \item controllo \textit{client-server}: un componente client chiede un servizio ad un componente server attraverso 
    una chiamata di proceduta e il componente server risponde
\end{itemize}
\subsubsection*{Modellazione del comportamenti ad oggetti}
I componenti del sistema sono considerati come oggetti che interagiscono. Un \textit{oggetto} è definito da \textit{attributi} e 
\textit{operazioni}. Gli oggetti comunicano tra di loro attraverso lo scambio di messaggi.
\section{Collaudo}
La fase di collaudo avviene alla fine dell'implementazione del sistema. Si ricercano e correggono difetti, si controlla 
che il prodotto realizzi ogni servizio senza malfunzionamenti (fase di \textit{verifica}) e che soddisfi i requisiti del 
committente (fase di \textit{validazione}).
\subsection{Ispezione}
\subsubsection*{Motivazioni}
L'\textit{ispezione} è una tecnica statica di analisi del codice, basata sulla lettura di questo e della documentazione.
L'ispezione è meno costosa del testing e può essere eseguita su una versione incompleta del sistema, ma alcuni requisiti 
non funzionali non si possono collaudare solo con l'ispezione (efficienza, affidabilità...).

Un team analizza il codice e segnala i possibili difetti. Viene seguita una checklist che indica i possibili difetti da 
investigare: 
\begin{itemize}
    \item errori nei dati 
    \item errori di controllo 
    \item errori di I/O 
    \item errori di interfaccia 
    \item errori nella gestione della memoria 
    \item errori di gestione delle eccezioni 
\end{itemize}
\subsubsection*{Ruoli nel team di ispezione}
Il team di ispezione è composto da \textit{autori} del codice, che correggono i difetti rilevati durante l'ispezione, 
\textit{ispettori}, che trovano difetti, e \textit{moderatore}, che gestisce il processo di ispezione.
\subsubsection*{Processo di ispezione}
Durante la fase di \textit{pianificazione}, il moderatore seleziona gli ispettori e controlla che il materiale sia completo.

Durante la fase di \textit{introduzione}, il moderatore organizza una riunione preliminare con autori e ispettori, nella 
quale è discusso lo scopo del codice e la checklist da seguire.

Durante la fase di \textit{preparazione individuale}, gli ispettori studiano il materiale e cercano difetti nel codice 
in base alla checklist ed all'esperienza personale.

Durante la fase di \textit{riunione di ispezione}, gli ispettori indicano i difetti individuati.

Durante la fase di \textit{rielaborazione}, il programma è modificato dall'autore per correggere i difetti.

Durante la fase di \textit{prosecuzione}, il moderatore decide se è necessario un ulteriore processo di ispezione.
\subsubsection*{Analisi statica del codice}
Gli strumenti CASE supportano l'ispezione del codice eseguendo su di esso l'\textit{analisi del flusso di controllo}, 
che assicura l'assenza di cicli con uscire multiple, salti incondizionati e codice non raggiungibile; l'\textit{analisi 
dell'uso dei dati}, che assicura l'assenza di problemi legati alle variabili; l'\textit{analisi delle interfacce} e 
l'\textit{analisi della gestione della memoria}. Due strumenti per l'analisi statica sono il compilatore gcc e SonarQube.

L'analisi statica precede l'ispezione del codice fornendo informazioni utili all'individuazione dei difetti, ma non è 
sufficiente.
\subsection{Testing}
\subsubsection*{Processo di testing}
Durante la fase di \textit{testing}, sono preparati ed eseguiti i test case, ed i loro risultati in output sono confrontati 
con quelli attesi.

Nella fase di \textit{debugging} viene controllata l'esecuzione del programma e il valore delle variabili, in modo da 
individuare l'errore. L'errore viene corretto e viene eseguito un \textit{testing di regressione}, nel quale si ripete 
l'ultimo test-case e tutti quelli precedenti.
\subsubsection{Test-case}
Un \textit{test-case} è composto da dati in input e dati in output attesi. 

Esistono due approcci per scegliere test-case. Nel testing \textit{black box}, la scelta dei test-case è basata sulla 
conoscenza di quali sono i dati in input e quelli in output. 

Dato l'insieme dei dati in input e l'insieme dei dati in 
output, una \textit{partizione di equivalenza} è un sottoinsieme dei dati in input per cui il sistema produce sempre lo 
stesso dato in output (oppure simili). Si può fare black box testing usando delle partizioni di equivalenza.
Per scrivere test-case, si individuano le partizioni di equivalenza e si scelgono un numero finito di test-case: in 
particolare si scelgono test-case con dati I/O al confine delle partizioni di equivalenza (\textit{Boundaty Value Analysis}).

Nel testing \textit{white box}, la scelta dei test-case è basata sulla struttura del codice. L'obiettivo è testare ogni 
parte del codice. Il codice viene rappresentato con un \textit{flow graph}, un grafo che rappresenta i possibili cammini 
nel codice.
\subsubsection{Complessità ciclomatica}
Nel codice, un cammino si dice \textit{indipendente} se introduce almeno una nuova sequenza di istruzioni o una nuova 
condizione. Il numero di cammini indipendenti equivale alla \textit{complessità ciclomatica} (CC) del flow graph. CC è 
il numero minimo di test-case richiesti per eseguire almeno una volta ogni parte del codice. I \textit{dynamic program
analyser} sono strumenti CASE che, dato un test-case, indicano quali parti del codice sono state interessate da un 
test-case e quali sono ancora da testare.
\subsubsection*{Testing d'integrazione}
I componenti possono essere implementati gradualmente oppure contemporaneamente. Il testing riguarda ciascun componente 
e la sua integrazione nel sistema. Prima vengono testati i componenti in maniera isolata, poi viene testato il sistema 
con le componenti integrate fino ad allora 
\end{document}
