\documentclass[11pt]{article}
\usepackage[margin=.8in]{geometry}
\usepackage[italian]{babel}
\usepackage{amsmath}
\usepackage{example}
\usepackage{forest}

\title{Appunti FLT}

\begin{document}
\section*{Nota ai lettori}
Questi appunti sono basati sulle lezioni dell A.A. 2023/2024, integrate con passi tratti dal libro "Linguaggi Formali e 
Compilazione", e formattati seguendo la suddivisione in paragrafi di quest'ultimo.
\section{Teoria formale del linguaggio}
\subsection{Alfabeto e linguaggio}
Un \textbf{alfabeto} è un insieme finito di elementi chiamati \textbf{simboli terminali} o \textbf{caratteri}.
$\Sigma=\{a_1,a_2,\dots,a_k\}$ è un alfabeto composto da $k$ elementi (la sua cardinalità è $k$). Una \textbf{stringa} (o 
\textbf{parola}) è una sequenza, ovvero un insieme ordinato eventualmente con ripetizioni, di caratteri.

Un \textbf{linguaggio} è un insieme di stringhe di un alfabeto specifico. Dato un linguaggio, una stringa che gli appartiene 
è detta \textbf{frase}. 

La \textbf{cardinalità} di un linguaggio è definita dal numero di frasi che contiene. Se la cardinalità è finita, il linguaggio 
si dice \textbf{finito}. 

Un linguaggi finito è una collezione di parole, solitamente chiamate \textbf{vocabolario}. Il linguaggio che non contiene 
frasi è chiamato \textbf{insieme vuoto} o \textbf{linguaggio $\emptyset$}.

La \textbf{lunghezza} $|x|$ di una stringa $x$ è il numero di caratteri che contiene.
\subsubsection{Operazioni sulle stringhe}
Date le stringhe
\begin{align*}
    x=&a_1a_2\dots a_h   &   y=&b_1b_2\dots b_k
\end{align*}
la \textbf{concatenazione}, indicata con $\cdot$, è definita come:
\begin{align*}
    x\cdot y=a_1a_2\dots a_hb_1b_2\dots b_k
\end{align*}
La concatenazione non è commutativa, ma è associativa.
\subsubsection{Stringa vuota}
La \textbf{stringa vuota} (o \textbf{nulla}), denotata con $\epsilon$, soddisfa l'identità:
\begin{align*}
    x\cdot \varepsilon=\varepsilon \cdot x = x
\end{align*}
La stringa vuota non deve essere confusa con l'insieme vuoto; infatti, l'insieme vuoto è un linguaggio che non contiene 
stringhe, mentre il set $\{\varepsilon\}$ ne contiene una, la stringa vuota.
\subsubsection{Sottostringa}
Sia la stringa $x=uyv$ il prodotto della concatenazione delle stringhe $u$, $y$ e $v$: le stringhe $u$, $y$ e $v$ sono 
\textbf{sottostringhe} di $x$. In questo caso, la stringa $u$ è un \textbf{prefisso} di $x$ e la stringa $v$ è un 
\textbf{suffisso} di $x$. Una sottostringa non vuota è detta \textbf{propria} se non coincide con $x$.
\subsubsection{Inversione di stringa}
L'\textbf{inverso} di una stringa $x=a_1a_2\dots a_h$ è la stringa $x^R=a_ha_{h-1}\dots a_1$.
\subsubsection{Ripetizione}
La potenza m-esima $x^m$ di una stringa $x$ è la concatenazione di $x$ con se stessa per $m-1$ volte. Esempi:
\begin{align*}
    x=&ab    &   x^0=&\varepsilon    &   x^2=&(ab)^2=abab\\  
\end{align*}
\subsection{Operazioni sul linguaggio}
L'inverso $L^R$ di un linguaggio $L$ è l'insieme delle stringhe che sono l'inverso di una frase di $L$.

\section{Automi a pila e parsing}
\subsection{Automi a pila}
Gli \textbf{automi a pila} sono automi a stati finiti che utilizzano una \textbf{pila} (stack) come memoria aggiuntiva.

Un automa a pila è definito dalla 7-upla 
\begin{equation*}
    \langle Q,\Sigma,\Gamma,\delta,q_0,Z_0,F \rangle
\end{equation*}
con:
\begin{itemize}
    \item $Q$: insieme degli stati
    \item $\Sigma$: alfabeto che descrive il linguaggio
    \item $\Gamma$: alfabeto della pila 
    \item $\delta$: funzione di transizione
    \item $q_0$: stato iniziale 
    \item $Z_0$: fondo della pila 
    \item $F$: stato (o stati) finale
\end{itemize}
L'input è una tripla, denotata come:
\begin{equation*}
    (q,a,A)\rightarrow(x,XX)
\end{equation*}
con:
\begin{itemize}
    \item $q$: stato corrente
    \item $a$: il simbolo della stringa da leggere
    \item $A$: il contenuto dello stack
\end{itemize}
Il simbolo di fine stringa è $\swarrow$.
\subsubsection{Tipi di accettazione}
Negli automi a pila ci sono due tipi di accettazione: l'\textbf{accettazione per stato finale}, quando è stato consumato 
tutto l'input e si giunge ad uno stato finale, e l'\textbf{accettazione per pila vuota}, quando è stato consumato tutto 
l'input e la pila è vuota (anche senza $Z_0$).

Essendo l'automa non deterministico, bisogna fare tutte le computazioni possibili (quindi esplorare tutte le possibilità).
\subsubsection{Esempio di accettazione per stato finale}
Processiamo una stringa nella forma $ca^nb^n$ con $n\geq 1$, ad esempio $caabb\swarrow$. 
\begin{equation*}
    \Gamma=\{Z_0,X\}
\end{equation*}
$Z_0$ è sempre presente, $X$ è il simbolo che gestisce il bilanciamento. Consumando $c$, si passa dallo stato $q_0$ allo 
stato $q_1$.
\begin{equation*}
    (q_0,c,Z_0)\rightarrow(q_1,Z_0)
\end{equation*}
Ora non sarà più possibile incontrare $c$. Consumiamo $a$:
\begin{equation*}
    (q_1,a,Z_0)\rightarrow(q_1,Z_0X)
\end{equation*}
$X$ serve a contare le $a$. La funzione $(q_1,Z_0X)$ rimane in $q_1$; la testa della pila contiene $X$, quindi la funzione
$(q_1,a,Z_0)$ non può scattare. Bisogna definire una nuova:
\begin{equation*}
    (q_1,a,X)\rightarrow(q_1,XX)
\end{equation*}
Se la parola è corretta, prima o poi si incontrerà una $b$. Passiamo allo stato $q_2$ per non incontrare più $a$.
\begin{equation*}
    (q_1,b,X)\rightarrow(q_2,\varepsilon)
\end{equation*}
Non può esserci $Z_0$, altrimenti sarebbe come se non avessimo mai incontrato nessuna $a$. Il passaggio a $q_2$ è obbligato.
\begin{equation*}
    (q_2,b,X)\rightarrow(q_2,\varepsilon)
\end{equation*}
\begin{equation*}
    (q_2,\swarrow,X)\rightarrow(q_3,Z_0)
\end{equation*}
Incontrerò il fine stringa quando aavrò rimosso tutti gli $X$ dalla pila. Lo stato finale conterrà solo $q_3$.
\begin{center}
    \begin{tabular}{ |c|c|c|c| }
     \hline
     Input & Pila & Stato & Commenti \\ 
     \hline\hline
     $caabb\swarrow$ & $Z_0$ & $q_0$ & devo consumare $c$ e $Z_0$ \\ 
     $aabb\swarrow$ & $Z_0$ & $q_1$ & devo consumare $a$ \\ 
     $abb\swarrow$ & $Z_0X$ & $q_1$ & devo trovare tripla $(q_1,a,X)$ \\ 
     $bb\swarrow$ & $Z_0XX$ & $q_1$ & ogni volta che incontro una $a$, metto $X$ sulla pila \\ 
     $b\swarrow$ & $Z_0X$ & $q_2$ & consumo la testa della pila, non scrivo nulla \\ 
     $\swarrow$ & $Z_0$ & $q_2$ & \\ 
     $ $ & $Z_0$ & $q_3$ & la parola appartiene al linguaggio \\ 
     \hline
    \end{tabular}
\end{center}
\subsubsection{Regole di produzione}
Una \textbf{grammatica context free} genera da un non terminale una sequenza di terminali e non terminali, combinati in qualunque 
modo; è una quadrupla nella forma 
\begin{equation*}
    G=\langle V,\Sigma,P,S\rangle
\end{equation*}
È possibile usare l'automa a pila per simulare la fase di generazione: quando trovo un non terminale, posso sostituirlo 
con un terminale o un non terminale.

La costruzione della funzione di transizione viene guidata dalle regole di produzione.
Il funzionamento dell'automa a pila è il seguente: controllo l'elemento in cima alla pila, individuo la regola di produzione 
corrispondente e la applico. 

Esistono 4 categorie di regole di generazione: regola di \textbf{inizializzazione}, regola di \textbf{terminazione}, 
regole \textbf{derivate da $P$} e regole \textbf{derivate da $\Sigma$}.
Per qualunque tripla, si può applicare più di una regola.
\paragraph*{Inizializzazione}
Questa regola permette di far partire la generazione, corrisponde a mettere sulla pila l'assioma $S$.
\begin{equation*}
    (q_0,\varepsilon,Z_0)\rightarrow(q_0,\swarrow S)
\end{equation*}
Implico il trovarmi in $q_0$ e dover transizionare in $q_0$. Non consumo nulla, ma modifico il contenuto della pila. 
Accettando per pila vuota, non bisogna includere $Z_0$.
\paragraph*{Terminazione}
Questa regola permette di terminare la generazione; l'ultimo simbolo in input è quello di fine stringa ($\swarrow$).
\begin{equation*}
    (q_0,\swarrow,\swarrow)\rightarrow(q_0,\varepsilon)
\end{equation*}
La generazione termina quando l'automa incontra il simbolo di fine stringa. Non viene scritto nulla sulla pila, ma si rimuove 
$\swarrow$, terminando la generazione.
\paragraph*{Regole per $\Sigma$}
Esiste una regola per ogni simbolo dell'alfabeto ($\forall a\in \Sigma$).
\begin{equation*}
    (q_0,a,a)\rightarrow(q_0,\varepsilon)
\end{equation*}
Il simbolo in cima alla pila viene consumato.
Esistono due tipi di regole di produzione per $a$, quelle che \textbf{iniziano con un terminale} 
\begin{equation*}
    (q_0,a,A)\rightarrow(q_0,\beta^R)\quad per \quad A\rightarrow a\beta
\end{equation*}
e quelle che \textbf{iniziano con un non terminale}
\begin{equation*}
    (q_0,\varepsilon,A)\rightarrow(q_0,\beta^R X)\quad per \quad A\rightarrow X\beta
\end{equation*}
\subsubsection{Esempio di accettazione per pila vuota}
Creiamo un automa a stati finiti non deterministico che accetta per \textbf{pila vuota}:
\begin{itemize}
    \item $Q=\{q_0\}$: perchè si può gestire il tutto con un solo stato (dato il non determinismo) e l'insieme degli stati finali è vuoto.
    \item $\Sigma=\Sigma$: l'alfabeto è quello del linguaggio
    \item $\Gamma=\{Z_0,\dots\}$: conterrà sicuramente il simbolo di fine pila, più tutti i simboli scrivibili sulla pila 
    \item $F=\{\emptyset\}$: l'insieme degli stati finali è vuoto
\end{itemize}

L'alfabeto della pila è definito come
\begin{equation*}
    \{Z_0\}\cup \Sigma \cup V
\end{equation*}
ovvero l'unione del simbolo di fine pila e gli insiemi dei simboli terminali e non terminali.

Regole di produzione:
\begin{align*}
    S&\rightarrow aBA & S&\rightarrow bcS & B&\rightarrow Ba & B&\rightarrow A & A&\rightarrow ac & A&\rightarrow AA
\end{align*}
La funzione di transizione è composta da 11 regole. Le seguenti regole di inizializzazione e terminazione
\begin{align*}
    (q_0,\varepsilon,Z_0)&\rightarrow(q_0,\swarrow S) & (q_0,\swarrow,\swarrow)&\rightarrow(q_0,\varepsilon)
\end{align*}
sono comuni a tutti i linguaggi.

Le regole
\begin{align*}
    (q_0,a,a)&\rightarrow(q_0,\varepsilon) & (q_0,b,b)&\rightarrow(q_0,\varepsilon) & (q_0,c,c)&\rightarrow(q_0,\varepsilon)
\end{align*}
non scrivono nulla sulla pila. 

Infine
\begin{align*}
    (q_0,a,S)&\rightarrow(q_0,AB) & (q_0,b,S)&\rightarrow(q_0,Sc) & (q_0,\varepsilon,B)&\rightarrow(q_0,aB)\\
    (q_0,\varepsilon,B)&\rightarrow(q_0,A) & (q_0,a,A)&\rightarrow(q_0,c) & (q_0,\varepsilon,A)&\rightarrow(q_0,AA)
\end{align*}

Generiamo la stringa $aacac$ sequendo le regole di produzione ed esaminiamola.
\begin{equation*}
    S\rightarrow aBA\rightarrow aAA \rightarrow aacA \rightarrow aacac
\end{equation*}
\begin{center}
    \begin{tabular}{ |c|c|c|c| }
     \hline
     Input & Pila & Stato & Regola di produzione \\ 
     \hline\hline
     $aacac\swarrow$ & $Z_0$ & $q_0$ & $(q_0,\varepsilon,Z_0)\rightarrow(q_0,\swarrow S)$ \\ 
     $aacac\swarrow$ & $\swarrow S$ & $q_0$ & $(q_0,a,S)\rightarrow(q_0,AB)$ \\ 
     $acac\swarrow$ & $\swarrow AB$ & $q_0$ &  $(q_0,\varepsilon,B)\rightarrow(q_0,A)$\\ 
     $acac\swarrow$ & $\swarrow AA$ & $q_0$ & $(q_0,a,A)\rightarrow(q_0,c)$ \\ 
     $cac\swarrow$ & $\swarrow Ac$ & $q_0$ &  $(q_0,c,c)\rightarrow(q_0,\varepsilon)$\\ 
     $ac\swarrow$ & $\swarrow A$ & $q_0$ & $(q_0,a,A)\rightarrow(q_0,c)$ \\ 
     $c\swarrow$ & $\swarrow c$ & $q_0$ & $(q_0,c,c)\rightarrow(q_0,\varepsilon)$ \\
     $\swarrow$ & $\swarrow$ & $q_0$ & $(q_0,\swarrow,\swarrow)\rightarrow(q_0,\varepsilon)$ \\ 
     \hline
    \end{tabular}
\end{center}
\subsection{Parsing}
L'\textbf{albero di derivazione} è creato durante la parsificazione. 

Si possono avere due politiche diverse durante la 
derivazione di un albero: \textbf{dall'alto verso il basso} e \textbf{dal basso verso l'alto}.
Parser di questo tipo sono automi a pila.
\subsubsection{Parser di tipo $LR(0)$}
Vediamo un parser di tipo $LR(0)$.

Con 0 intendiamo che, oltre a consumare un simbolo in input, \textbf{legge 0 altri simboli}.

Con $L$ intendiamo \textbf{left}: il parser parte da sinistra con la lettura.

Con $R$ intendiamo \textbf{rightmost}: il parser cerca la regola della grammatica da utilizzare partendo da quella più a destra.

Si inseriscono nodi nell'albero ogni volta che si effettua una riduzione.
Ad esempio, date le seguenti regole di produzione
\begin{align*}
    E&\rightarrow id & S&\rightarrow E+E
\end{align*}
si ottiene l'albero
\begin{center}
    \begin{forest}
        for tree={
            grow=south,
            circle, draw, minimum size=3ex, inner sep=1pt,
            s sep=7mm, tier/.pgfmath=level()
                }
        [S
            [E
                [id, tier=number]
            ]
            [+, tier=number]
            [E
                [id, tier=number]
            ]
        ]
    \end{forest}
\end{center}
$LR(0)$ è un'\textbf{automa a pila deterministico}: in ogni momento della parsificazione è possibile compiere una sola 
azione (o nessuna). Il suo compito è accettare o rifiutare una stringa in input. Sono inoltre possibili due operazioni:
\begin{itemize}
    \item \textbf{SHIFT}: leggo input e lo trascrivo sulla pila 
    \item \textbf{REDUCE}: operazione legata ad una regola grammaticale; consuma simboli dalla pila e li sostituisce 
\end{itemize}
L'operazione di REDUCE non modifica la pila, fa una serie di pop e poi fa una push.

Finora, gli stati sono stati identificati per label. In $LR(0)$ gli stati sono etichettati con "SHIFT" o "REDUCE" e contengono 
informazioni utili a determinare il tipo di operazione da svolgere.

Un parser $LR(0)$ non gestisce tutte le grammatiche context free, ma è possibile costruire un parser a partire da una di
queste.

Durante la parsificazione di possono verificare due problemi:
\begin{itemize}
    \item il comportamento non è deterministico: alcuni stati hanno due o più comandi
    \item si possono avere più operazioni di reduce, ognuna legata ad una regola diversa (qual è quella corretta)
\end{itemize}
Inoltre, \textbf{non} è possibile fare contemporaneamente operazioni di SHIFT e REDUCE oppure due operazioni di REDUCE in 
parallelo.

Un automa a pila deterministico ha all'interno dei suoi stati dei candidati legati alla regola di produzione.
$A\rightarrow a^\beta$
\end{document}